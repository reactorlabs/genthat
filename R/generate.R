
toStringLiteral <- function (str) {
    concatVec(deparse(str))
}

listToArgumentList <- function(args) {
    elems <- c()
    argNames <- names(args)
    for (i in seq(along.with = args)) {
        src <- if (length(argNames) != 0 && argNames[[i]] != "") {
            concat(argNames[i], " = ", args[[i]])
        } else {
            args[[i]]
        }
        elems <- c(elems, src) 
    }
    concatVec(elems, sep=", ")
}

#' @title Test Case generator based on capture files
#'
#' @description This function works with the trace information generated by instrumented GNU-R.
#'
#' It is strictly oriented to that, please see readme for more information.
#'
#' @param root a directory containg capture information or capture file
#' @param output_dir directory where generated test cases will be saved
#' @param verbose wheater display debug output
#' @param timed whether result is dependent on time of generation
test_gen <- function(root, output_dir, timed = F, verbose = FALSE) {
  if (verbose) {
    cat("Output:", output_dir, "\n")
    cat("Root:", root, "\n")
  }
  # input dir checks
  if (missing(root) || !file.exists(root)) {
    stop("Input dir/file doesn't exist!")
  }
  all.capture <- if (!file.info(root)$isdir) root else lapply(list.files(root, recursive=TRUE, all.files = TRUE), function(x) file.path(root,x))
  # output dir checks
  if (missing(output_dir)) stop("A output directory must be provided!");
  if (!file.exists(output_dir) || !file.info(output_dir)$isdir) dir.create(output_dir)
  if (timed)
    output_dir <- file.path(output_dir, format(Sys.time(), "%Y-%m-%d %H:%M:%S"))
  cache$output_dir <- output_dir
  # bad.arguments file to store incorrect arguments
  cache$bad_argv <- file.path(cache$output_dir, "bad_arguments");
  if (!file.exists(cache$bad_argv)
      && !file.create(cache$bad_argv))
      stop("Unable to create file: ", cache$bad_argv)
  cache$tid <- list()
  ret <- Map(function(x) { process_capture(x) }, all.capture)
  cache$output_dir <- NULL
  cache$bad_argv <- NULL
  ret
}

#' @title Manage Test Case file
#'
#' @description This function creates a test case file if one does not exist already
#' @param name directory where generated test cases will be saved
#' @seealso test_gen
ensure_file <- function(name) {

    fname <- gsub(.Platform$file.sep, "sep", name)
    # replace ::: with ___ so that we work on Windows too
    fname <- gsub(":::", "___", fname)
    # check if the folder for the function exists and create it if not
    tc.folder = file.path(cache$output_dir, fname, fsep = .Platform$file.sep)
    dir.create(tc.folder, showWarnings = FALSE)
    # get the index of the file, based on number of files in the folder (but use the cache information for it)
    cache$tid[[name]] <- if (is.null(cache$tid[[name]])) { 0L } else { cache$tid[[name]] + 1L }
    tc.file = file.path(tc.folder, paste("test-", cache$tid[[name]], ".R", sep=""), fsep = .Platform$file.sep)
    # the file should not exist
    if (!file.create(tc.file))
        stop("Unable to create file: ", tc.file)
    # TODO perhaps this is not needed for testthat
    write("library(testthat)", file = tc.file, append = TRUE)
    write("", file = tc.file, append = TRUE)
    # write context information (the function name)
    write(paste("context(\"",name,"\")\n", sep=""), file = tc.file, append = TRUE)
    return(tc.file)
}

#' @title Process File with Closure capture information
#'
#' @description This function parses file with closure capture information and generates test cases
#' @param cap_file path to closure capture file
process_capture <- function(cap_file) {
  lines <- readLines(cap_file)
  cache$i <- 1
  cache$generated_tests <- 0L
  cache$retv_mismatch_count <- 0L
  cache$unparsable_count <- 0L
  ret <- list()
  while (cache$i < length(lines)) {
    # read test case information
    func <- read_value(lines, kFuncPrefix)
    args <- read_value(lines, kArgsPrefix)
    retv <- read_value(lines, kRetvPrefix)

    if (args != "<unserializable>") { # TODO ???
        feedback <- generate_tc(func, args, retv)

        #### see what we get
        if (feedback$type == "err") {
          # the captured information is not usable
          write(feedback$msg, file=cache$bad_argv, append=TRUE);
        } else if (feedback$type == "src") {
          #### good, we get the source code
          tc.file <- ensure_file(func)
          write(feedback$msg, file=tc.file, append=TRUE);
        } else {
          stop("Unexpected generate_tc() return value!");
        }
        ret <- c(ret, list(feedback))
    } else {
        # TODO
    }
  }
  ret
}

read_value <- function(lines, prefix){
  value <- vector()
  j <- cache$i
  while (TRUE) {
    if (identical(lines[j], "")) {
      j <- j + 1
      next
    } else if (starts_with(prefix, lines[j])) {
      value <- c(value, strip_prefix(prefix, lines[j]))
      j <- j + 1
    } else {
      break
    }
  }
  cache$i <- j
  paste(value, collapse="\n", sep="")
}

#' Do we have access to the function in test generation phase, to recompute the return value from the arguments?
#'
#' @param function.name string name of binding
#' @return boolean value signaling whether evaluating the supplied function name in the global scope yields the function or not.
#'
#' @examples
#' isAccessibleFunction("myFn1") == FALSE
#' isAccessibleFunction("ggplot2::ggplot") == TRUE
isAccessibleFunction <- function(function.name) {
    length(grep("::", function.name)) != 0 # TODO handle functions and package-names containing "::"
}

#' @title Generates a testcase for closure function
#'
#' @description This function generates a test case for builtin function using supplied arguments. All elements should be given as text.
#' @param func function name
#' @param argv input arguments for a closure function call
#' @seealso test_gen ProcessClosure
generate_tc <- function(func, argv, retv) {
  # check validity of arguments
  deserialize <- function(x) eval(parse(text=x))
  valid.argv <- tryCatch(deserialize(argv), error = function(e) "GENTHAT_UNPARSEABLE")
  valid.retv <- tryCatch(deserialize(retv), error = function(e) "GENTHAT_UNPARSEABLE")

  # proper arguments should always be packed in a list
  if (identical(valid.argv, "GENTHAT_UNPARSEABLE") || identical(valid.retv, "GENTHAT_UNPARSEABLE")) {
      cache$unparsable_count <- cache$unparsable_count + 1L
      list(
          type = "err",
          err_type = "UNPARSEABLE",
          msg = paste(
            paste0("cause: ", "UNPARSEABLE"),
            paste0("func: ", func),
            paste0("argv: ", argv),
            paste0("retv: ", retv),
            "",
            sep = "\n"
          )
      )
  } else {
      cache$warns <- NULL
      cache$errs <- NULL
      test_body <- ""
      warningChecks <- ""

      message(paste0("generating from call to: ", func, "\n"))

      if (isAccessibleFunction(func)) {
          pkgName <- sub("^(.*):::.*$", "\\1", func)
          fn <- eval(parse(text=func))
          call <- as.call(if (0 == length(valid.argv)) list(fn) else append(fn, valid.argv))

          new.retv <- withCallingHandlers(
                        tryCatch(
                            eval(call, envir = getNamespace(pkgName)),
                            error = function(e) cache$errs <- e$message
                        ),
                        warning=function(w) {
                            cache$warns <- ifelse(is.null(cache$warns), w$message, paste(cache$warns, w$message, sep="; "))
                            invokeRestart("muffleWarning")
                        }
                  )

          et <- system.time({ sameRetv <- isTRUE(all.equal(new.retv, valid.retv)) })[1]
          message(paste0("all.equal time: ", et, " seconds\n"))
          if (!sameRetv) {
              cache$retv_mismatch_count <- cache$retv_mismatch_count + 1L
              return(list(
                  type = "err",
                  err_type = "RETV_MISMATCH",
                  msg = paste(
                    paste0("cause: ", "RETV_MISMATCH"),
                    paste0("func: ", func),
                    paste0("argv: ", argv),
                    paste0("retv: ", retv),
                    paste0("computed.retv: ", serialize_r(new.retv)),
                    "",
                    sep = "\n"
                 )
              ))
          }
          
      }

      cache$generated_tests <- cache$generated_tests + 1L
      argSources <- Map(serialize_r, valid.argv)
      callSource <- concat(func, "(", listToArgumentList(argSources), ")")

      if (!is.null(cache$errs)) {
          test_body <- paste(
            "\texpect_error({\n",
            "\t", callSource, "},\n",
            "\t", deparse(cache$errs), ")\n"
          )
      } else {
          test_body <- concat(
              "\texpected <- ", retv, "\n",
              "\texpect_equal(", callSource, ", expected)\n"
          )
      }

      warningChecks <- if (!is.null(cache$warns) && length(cache$warns) > 0) paste("\texpect_warning(", callSource, ", ", deparse(cache$warns), ")\n", sep="") else ""

      src <- concat(
        "test_that(", deparse(func), ", {\n",
        test_body,
        warningChecks,
        "})"
      )

      list(
        type = "src",
        msg = src
      )
  }
}

#' @title Generates tests from captured information.
#'
#' @description This function takes the tracing information collected by capture and generates
#' testthat compatible testcases.
#'
#' @param output_dir Directory to which the tests should be generated.
#' @param root Directory with the capture information, defaults to capture.
#' @param timed TRUE if the tests result depends on time, in which case the current date & time will be appended to the output_dir.
#' @param verbose TRUE to display additional information.
#' @param clear_capture if FALSE captured traces will not be deleted after the generation so that subsequent calls to generate() can use them too
#' @export
generate <- function(output_dir, root,
                     timed = F, clear_capture = T, verbose = FALSE) {
    out <- if (missing(output_dir)) "generated_tests" else output_dir
    if (missing(output_dir)) {
        if (!dir.create(out)) {
            stop("Couldn't create output dir.")
        }
    }
    cache$output.dir <- out
    ret <- test_gen(root, out, timed, verbose = verbose);
    if (clear_capture) {
        unlink(file.path(root, list.files(path = root, no.. = T)))
    }
    ret
}

